import os
import json
from http.server import BaseHTTPRequestHandler, HTTPServer
from socketserver import ThreadingMixIn
import threading
import time
import requests
from concurrent.futures import ThreadPoolExecutor
import multiprocessing

# Environment variables or constants setup
REQUIRED_TOKEN = "initial_required_token"  # This will be rotated
AIRANCH_TOKEN = "your_airanch_token_here"
AIRANCH_URL = "your_airanch_url_here"
NODE_UUID = "your_node_uuid_here"
TOKEN_ROTATION_MINUTES = 10  # Rotate token every X minutes
FORWARD_PORT = 8081

def update_required_token():
    global REQUIRED_TOKEN
    headers = {"Authorization": f"Bearer {AIRANCH_TOKEN}"}
    data = {"node_uuid": NODE_UUID}
    try:
        # Make an outbound call to AIRANCH_URL
        response = requests.post(AIRANCH_URL, headers=headers, json=data)
        response.raise_for_status()
        # Assuming the response contains a JSON with the new token
        new_token = response.json().get("new_token")
        if new_token:
            REQUIRED_TOKEN = new_token
            print(f"REQUIRED_TOKEN updated successfully: {REQUIRED_TOKEN}")
        else:
            print("Failed to update REQUIRED_TOKEN: No token in response")
    except Exception as e:
        print(f"Error updating REQUIRED_TOKEN: {e}")

def rotate_token_periodically():
    while True:
        update_required_token()
        time.sleep(TOKEN_ROTATION_MINUTES * 60)

# Start the token rotation in a separate background thread
threading.Thread(target=rotate_token_periodically, daemon=True).start()

class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""
    executor = ThreadPoolExecutor(max_workers=multiprocessing.cpu_count())

class ProxyHTTPRequestHandler(BaseHTTPRequestHandler):
    protocol_version = 'HTTP/1.1'
    # Define the local service port you want to forward requests to
    

    def do_ALL(self):
        # Common method for handling all types of HTTP requests
        # Check for the token in headers
        token = self.headers.get('Authorization')
        if token != f"Bearer {REQUIRED_TOKEN}":
            self.send_response(401)  # Unauthorized
            self.end_headers()
            self.wfile.write(b"Unauthorized access")
            return

        try:
            # Forwarding the request to the specific port on localhost
            method = self.command
            # Rewrite the URL to forward to the specified port on localhost
            url = f"http://localhost:{self.FORWARD_PORT}{self.path}"
            
            # Exclude the Host header from the original request
            headers = {key: val for key, val in self.headers.items() if key != 'Host'}
            # Include any necessary headers for the forwarded request here
            headers['Host'] = f"localhost:{self.FORWARD_PORT}"
            
            data = self.rfile.read(int(self.headers['Content-Length'])) if 'Content-Length' in self.headers else None

            # Sending request to the modified final destination
            response = requests.request(method, url, headers=headers, data=data, allow_redirects=False)

            # Forwarding response back to the client
            self.send_response(response.status_code)
            for key, value in response.headers.items():
                self.send_header(key, value)
            self.end_headers()
            self.wfile.write(response.content)

        except Exception as e:
            self.send_error(500, str(e))

    def do_GET(self):
        self.do_ALL()

    def do_POST(self):
        self.do_ALL()

    def do_PUT(self):
        self.do_ALL()

    def do_DELETE(self):
        self.do_ALL()

    def do_OPTIONS(self):
        self.do_ALL()

    def do_HEAD(self):
        self.do_ALL()

def run(server_class=ThreadedHTTPServer, handler_class=ProxyHTTPRequestHandler, port=8080):
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    print(f"Starting threaded HTTP server on port {port}")
    httpd.serve_forever()

if __name__ == '__main__':
    run()
